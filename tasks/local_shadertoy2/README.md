# Локальный Shadertoy 1

**Зависимости: [shadertoy1](/tasks/shadertoy2/)**.

В данном задании вам предстоит познакомится с написанием приложений при помощи Vulkan.

Однако чтобы отрисовать даже один одинокий треугольник "с нуля" на Вулкане требуется не один день разбираться с горой разных абстракций и движущихся частей API.
Сложилась такая ситуация потому, что Vulkan разрабатывался для написания промышленных игровых движок, а не маленьких учебных приложений.
Для решения этой дилеммы мы будем использовать библиотеку, упрощающую работу с Вулканом, [Etna](https://github.com/alexandrShcherbakov/etna/).
Более того, в папке задания вам предоставлена простая заготовка, инициализирующая все необходимые библиотеки и подсистемы.

## Перед началом

 1. Скопируйте в данную папку решение задания [локальный Shadertoy 1](/tasks/local_shadertoy1/).
    Не забудьте поменять название таргета в CMakeLists.txt чтобы не было конфликтов, а также поменять макрос используемый для получения путей до шейдеров.
 2. Убедитесь, что вы не потеряли решение задания [Shadertoy 2](/tasks/shadertoy2/).
 3. Вспомните, как работают графические пайплайны и рендер-пассы в Вулкане.
 4. Обратите внимание, что чтобы использовать в шейдерах заголовочный файл `cpp_glsl_compat.h` необходимо подключить в `CMakeLists.txt` таргет `render_utils`, а чтобы использовать для загрузки изображений `stb_image.h` необходимо подключить таргет `scene`.

## Задание

Наша цель &mdash; заставить ваш код из домашки [shadertoy 1](/tasks/shadertoy1/) запускаться локально на вулкане.
Но, в отличии от shadertoy, мы будем пользоваться не фрагментным шейдером, а вычислительным.
Это наложит на нас некоторые ограничения: мы не сможем записывать результат шейдера прямо в так называемый *бэкбуфер*, а точнее текущую картинку свопчейна.
Вместо этого предлагается создать новую картинку (`etna::Image`) и записывать в неё результаты вычислительного шейдера при помощи *storage images*.
Обратите внимание, что *storage image* -- это не свойство самого изображения, а лишь способ забиндить почти произвольное изображение в шейдер и писать в него по произвольным координатам из произвольного треда.
Сам вычислительный шейдер необходимо запускать с достаточным количеством тредов чтобы цвет каждого пикселя вычислялся отдельным тредом.
После же мы просто "скопируем" наше изображение в бэкбуфер при помощи операции *blit*.

Поменяйте ваш код так, чтобы картинка считалась не в вычислительном шейдере, а во фрагментном.
Вместо compute-пайплайна используйте графический.
Вместо storage-текстур для записи результата шейдера используйте колор-атачменты.
Для этого вам, разумеется, придётся поместить запуск пайплайна в рендер-пасс.
Самый просто способ сделать это &mdash; использовать возможности Этны, поглядывая за вдохновением в семпл [shadowmap](/samples/shadowmap/).
Альтернативно можете самостоятельно использовать dynamic rendering Вулкана, поддерживаемый без расширений в нашей версии Вулкана.
Наконец, как самый сложный (и не сильно полезный) вариант, можете использовать "классические" объекты рендер-пассов вулкана.
Если вы вдруг использовали текстуры в первой домашке, пока что их придётся открутить.

Итак, по пунктам:

Замените текущий шейдер на написанный вами в задании [Shadertoy 2](/tasks/shadertoy2/).
Так как на самом деле это не один шейдер, а два (один генерирует процедурную текстуру, другой использует), вам придётся сделать ещё один рендер-пасс, ещё один пайплайн, запустить его перед основным и "скормить" на вход основному шейдеру вспомогательную процедурную текстуру.
Непроцедурные текстуры пока что открутите из шейдера.

### Шаг 3

Также вам придётся загрузить какую-нибудь картинку из [папки текстур](/resources/textures/), протянуть её в шейдер и использовать в качестве текстуры для трипланарной проекции.
Для загрузки файла картинки используйте `stb_image.h` (не забыв подключить `render_utils`), а для загрузки картинки на GPU используйте `etna::BlockingTransferHelper`.

### Бонусный уровень

- Разберитесь как загружать кубмапы и верните в ваш шейдер скайбокс.
  Ассет скайбокса вам придётся найти в интернете самостоятельно, желательно под лицензией CC0.
- Сгенерируйте загруженным текстурам MIP-уровни при помощи команды `blit`.

## Полезные материалы

 1. https://docs.vulkan.org/spec/latest/index.html &mdash; единый ресурс всего про Vulkan (документация, туториалы, гайды)
 2. https://www.khronos.org/opengl/wiki/OpenGL_Shading_Language &mdash; справочник по языку GLSL
 3. https://github.com/KhronosGroup/GLSL/blob/main/extensions/khr/GL_KHR_vulkan_glsl.txt &mdash; "дельта" поверх спецификации GLSL, адаптирующая его для работы с Vulkan вместо OpenGL.
